# Project 2实验报告
## 1.程序功能简要说明

本程序基于**CImg库**实现了对图像的简单处理，其具体功能如下：

### 1.1 图像数据的读取与展示

用户在控制台输入`1`后，程序提示“请输入图像文件名：”，用户输入想要展示的图片的文件名（ppm格式，带文件后缀），随后程序将该图像显示在UI窗口中

### 1.2 彩色图像转灰度

用户在控制台输入`2`后，程序提示“请输入彩色图像文件名：”，用户输入想要转为灰度图像的图片文件名（同样为带.ppm后缀的文件名），随后程序提示“请输入灰度图输出文件名”，这里用户需要输入想要生成的灰度图像的带.ppm后缀的文件名，紧接着程序将调用`colorToGray`函数，将彩色图像转为灰度，并调用`display`函数，将该灰度图像显示在UI窗口中，并把该图像信息以ascii码的ppm格式写入用户指定的文件中，在控制台输出“已保存标准 P2 灰度图像”

### 1.3 图像缩放

用户在控制台输入`3`后，程序提示“请输入原图文件名：”，用户输入需要缩放的图片文件名（带.ppm后缀），随后程序提示“输入目标宽和高：”和“请输入输出文件名：”，用户输入各自的信息后，程序将调用`resizeImage`函数，将图像缩放至用户指定的尺寸，并把它保存在用户指定的文件中，再在控制台输出“已保存缩放灰度图像(P2)/彩色图像(P3)”

### 1.4 图像压缩

用户在控制台输入`4`后，程序提示“请输入原图文件名：”和“请输入压缩输出文件名(txt)：”，用户输入对应信息后，程序将调用`compressImage`函数，使用**RLE（行程长度编码压缩算法）**对图像的三元组数据进行压缩编码后存储于用户指定的txt文件中，随后在控制台输出“已完成RLE压缩，结果保存至：xxx.txt”

### 1.5 图像解压

用户在控制台输入`5`后，程序提示“请输入压缩文件名(txt)”和“请输入解压输出文件名(ppm)”，用户输入对应信息后，程序调用`decompressImage`函数，读取从ppm文件压缩得到的txt文件中的RLE编码信息，将其解码并写入用户指定的ppm文件的三元组数据，写入完成后将此解压后的图像展示于UI窗口中，并在控制台输出“已解压灰度图/彩色图”和“已完成解压，可通过功能1查看解压后图像。”

## 2.程序运行界面展示

图片在本地，此处忽略

## 3.部分关键代码及其说明

### 3.1 对PPM格式图像的说明

本次实验中，本人所使用的图像格式均为ppm格式。这是因为其能够以ASCII码的形式存储图像中各个像素的深度(灰度图)/RGB(彩色图)信息，且能够方便地使用VSCode查看及更改文件中的信息。由于后续的函数中对图像的操作都是通过对ppm格式的文件进行修改而实现的，因此在此处简短介绍下ppm文件的格式

```bash
<魔数>
<宽度> <高度>
<最大像素值>
<像素数据>
```

- **魔数：**表示当前图像是灰度图或是彩色图
  - **P2**：灰度图像的 ASCII（纯文本）格式
  - **P3**：彩色图像的 ASCII（纯文本）格式
- **宽度、高度：**当前图像的宽度和高度
- **最大像素值：**色深，此处均设为255
- **像素数据：**以矩阵形式（灰度图）或三元组形式（彩色图）存储的各个像素的信息

以下分别为灰度图及彩色图的例子：

```bash
P2
128 128
255
162 162 176 150 150...
```

```bash
P3
128 128
255
150 150 150 162 1 162 100 90 100...
#三个像素为一组，分别为R、G、B
```

### 3.2 图像读取与显示的函数

```cpp
void showImage(const string &filename) {
    CImg<unsigned char> img(filename.c_str());//读取图像文件
    img.display(("Display: " + filename).c_str());//在UI窗口中显示图像
}
```

此处就是简单调用了CImg库中的`display`函数，实现了对ppm格式的图像的读取与显示

### 3.3 彩色图像转灰度图像的函数

通过查阅实验文档中的提供的网站，可以了解到彩色图像转为灰度图像的多种实现方式及特点

- 平均值法：Gray=（R+G+B）/3
  - 容易偏暗或偏色，绿色区域显得不够亮

- 最大值法：Gray = max(R,G,B)
  - 能增强亮部对比度，使高亮区域更突出
- 最小值法：Gray = min(R,G,B)
  - 结果整体偏暗，对比度低
- 加权平均值法：Gray=0.299R+0.587G+0.114B
  - 按照人眼敏感度进行不同权重划分后加权计算（对绿色最敏感，其次红色，最次蓝色）
- 仅取绿色：Gray=G
  - 对于绿色信息较少的图片可能难以反映原图效果

因此，在本实验中，选用加权平均值法实现彩色图像向灰度图的转换，如`rgbToGray`函数所示，此函数接受一个彩色图像，返回一个灰度图像
```cpp
CImg<unsigned char> rgbToGray(const CImg<unsigned char>& color) {
    CImg<unsigned char> gray(color.width(), color.height(), 1, 1, 0);
    cimg_forXY(color, x, y) {
        unsigned char r = color(x,y,0,0);
        unsigned char g = color(x,y,0,1);
        unsigned char b = color(x,y,0,2);
        // 使用常用的加权平均法转换为灰度值
        gray(x,y) = (unsigned char)(0.299*r + 0.587*g + 0.114*b);
    }
    return gray;
}
```

随后，在`colorTOGray`函数中调用此函数，得到灰度图，并进行格式化的写入，代码如下

```cpp
void colorToGray(const string &input, const string &output) {
    CImg<unsigned char> color(input.c_str());
    // 调用颜色转换函数
    CImg<unsigned char> gray = rgbToGray(color);
    gray.display("Gray Image");

    // 保存为 CImg 的 ASCII 格式
    gray.save_ascii(output.c_str());

    // 读取刚刚保存的内容
    ifstream fin(output);
    if (!fin) {
        cerr << "无法读取保存的文件：" << output << endl;
        return;
    }

    // 读取第一行
    string header_line;
    getline(fin, header_line);

    // 剩余部分（像素数据）
    string data((istreambuf_iterator<char>(fin)), istreambuf_iterator<char>());
    fin.close();

    // 重新写回并加上标准 P2 头部
    // 这里是因为Cimg库中使用save_ascii码得到的并非标准的ppm格式，需要为其添加文件头部信息，才能让XnViewer读取
    ofstream fout(output);
    fout << "P2\n" << gray.width() << " " << gray.height() << "\n255\n";
    fout << data;
    fout.close();

    cout << "已保存标准 P2 灰度图像：" << output << endl;
}
```

这一函数的主要操作其实是把CImg库中的`save_ascii`函数得到的数据进行格式化的处理，使其变为标准的ppm格式，从而能够被正常读取

### 3.4 图像缩放的函数

通过查阅实验文档中提供的网页中对于插值相关知识的介绍，发现使用**双线性插值方法**能够较好的实现对图像的缩放功能，其公式可表示为：$f(x,y)=(1-a)(1-b)f(x_1,y_1)+a(1-b)f(x_2,y_1)+(1-a)bf(x_1,y_2)+abf(x_2,y_2)$

其中

- $(x,y)$表示目标图像中的坐标
- $(x_1,y_1),(x_2,y_2),(x_1,y_2),(x_2,y_1)$表示原图中相邻的四个像素点
- $a=x-x_1,b=y-y_1$

```cpp
CImg<unsigned char> bilinearResize(const CImg<unsigned char>& src, int newW, int newH) {
    int oldW = src.width();
    int oldH = src.height();
    int channels = src.spectrum();

    CImg<unsigned char> dst(newW, newH, 1, channels, 0);
    // 计算比例因子
    double scaleX = (double)(oldW - 1) / (newW - 1);
    double scaleY = (double)(oldH - 1) / (newH - 1);
    //遍历每个像素位置，进行双线性插值计算
    for (int y = 0; y < newH; y++) {
        double srcY = y * scaleY;
        int y1 = (int)srcY;
        int y2 = min(y1 + 1, oldH - 1);
        double b = srcY - y1;

        for (int x = 0; x < newW; x++) {
            double srcX = x * scaleX;
            int x1 = (int)srcX;
            int x2 = min(x1 + 1, oldW - 1);
            double a = srcX - x1;
            //若通道为1，则为灰度图像，直接插值
            //若通道为3，则为彩色图像，对每个通道分别插值
            for (int c = 0; c < channels; c++) {
                double f11 = src(x1, y1, 0, c);
                double f21 = src(x2, y1, 0, c);
                double f12 = src(x1, y2, 0, c);
                double f22 = src(x2, y2, 0, c);
                // 双线性插值计算
                double value =
                    (1 - a) * (1 - b) * f11 +
                    a * (1 - b) * f21 +
                    (1 - a) * b * f12 +
                    a * b * f22;
                dst(x, y, 0, c) = (unsigned char)(value + 0.5);//四舍五入取整
            }
        }
    }
    return dst;
}
```

`bilinearResize`函数传入图像信息，缩放的目标宽度及缩放的目标高度，返回缩放后的图像信息

随后再在`resizeImage`函数中调用此函数，得到缩放后的图像

```cpp
void resizeImage(const string &input, const string &output, int newW, int newH) {
    CImg<unsigned char> src(input.c_str());//读取输入图像文件

    //调用Cimg库中的resize函数，使用interpolation_type=1的双线性插值实现缩放
    CImg<unsigned char> resized = bilinearResize(src, newW,newH);
    resized.display("Resized Image");

    int spectrum = resized.spectrum();  // 通道数，用于区分彩色图像和灰度图像

    //对于彩色和灰度图像，分别执行各自的存储方式
    if (spectrum == 1) {
        // 如果是灰度图像，就存储其ascii码，再修改其文件头部信息，变为标准的ppm格式
        resized.save_ascii(output.c_str());

        // 去掉CImg自定义头并替换为 P2 头
        ifstream fin(output);
        string header_line;
        std::getline(fin, header_line); // 跳过第一行
        string data((istreambuf_iterator<char>(fin)), istreambuf_iterator<char>());
        fin.close();

        ofstream fout(output);
        fout << "P2\n" << resized.width() << " " << resized.height() << "\n255\n";
        fout << data;
        fout.close();

        cout << "已保存缩放灰度图像 (P2):" << output << endl;
    }
    else if (spectrum == 3) {
        // 如果是彩色图像，由于save_ascii函数会将RGB三个色彩通道分开存储，导致无法得到正常的彩色图像，于是使用手动存储的方法
        ofstream fout(output);
        fout << "P3\n" << resized.width() << " " << resized.height() << "\n255\n";
        
        for (int y = 0; y < resized.height(); y++) {
            for (int x = 0; x < resized.width(); x++) {
                int r = resized(x, y, 0, 0);//表示红色通道
                int g = resized(x, y, 0, 1);//表示绿色通道
                int b = resized(x, y, 0, 2);//表示蓝色通道
                fout << r << " " << g << " " << b << " ";//手动写入RGB值
            }
            fout << "\n";
        }
        fout.close();

        cout << "已保存缩放彩色图像 (P3):" << output << endl;
    }
    else {
        cerr << "非标准通道数：" << spectrum << "，未保存。" << endl;
    }
}
```

在`resizeImage`函数中，将彩色图与灰度图分开存储，这是因为对于彩色图像，`save_ascii`函数会将RGB三个色彩通道分开存储，导致无法得到正常的彩色图像，于是使用手动存储的方法向ppm格式的图像文件中写入数据

此外，该函数还增加了一个报错的条件，即如果通道数不为`1`或`3`（即ppm格式图片有误）则传出报错信息

### 3.5 图像压缩的函数

对于图像压缩，通过查阅相关资料，发现**RLE算法（行程长度编码压缩算法）**能够实现对于图像数据的压缩

其原理为：**通过记录连续出现的相同像素值及其重复次数来代替原始的重复数据，从而减少数据存储量**。

在编码过程中，其从左到右依次扫描图像数据，当检测到一段连续相同的像素值时，仅保留该像素值与其出现次数的三元组信息。解码时，则根据该记录重复还原出原始的像素序列。由于自然图像中经常存在大面积相同或相近的颜色区域，使用此方法能够有效减少存储冗余，并实现无损压缩

考虑到压缩过程本质上是对ASCII码进行操作，因此使用txt这一格式来保存压缩后的图像文件，其格式为：
```bash
<宽><高><通道数># 3代表彩色图、1代表灰度图
<RLE编码得到的像素数据>
例如：
390 390 3
152 152 152 6256 151 151 151 1...
```
使用`compressImage`函数来实现对图像的压缩：
```cpp
void compressImage(const string &input, const string &compressedFile) {
    CImg<unsigned char> img(input.c_str());
    int w = img.width(), h = img.height(), c = img.spectrum();

    ofstream fout(compressedFile);
    fout << w << " " << h << " " << c << "\n";//在压缩的txt文件的开头写入图像的宽、高、通道数

    //对灰度图像和彩色图像分别进行RLE压缩
    if (c == 1) {  
        //灰度图像
        //例如：像素值序列为[5,5,5,2,2,3]，则压缩后为[(5,3),(2,2),(3,1)]
        vector<int> vals;
        for (int y = 0; y < h; y++)
            for (int x = 0; x < w; x++)
                vals.push_back(img(x, y));

        int count = 1;
        for (size_t i = 1; i <= vals.size(); i++) {
            if (i < vals.size() && vals[i] == vals[i - 1]) count++;
            else {
                fout << vals[i - 1] << " " << count << " ";
                count = 1;
            }
        }
    } else if (c >= 3) { 
        //彩色图像
        //由于彩色图像每个像素有三个通道，使用三元组(r,g,b)来表示一个像素值
        //例如：像素值序列为[(255,0,0),(255,0,0),(0,255,0)]，则压缩后为[((255,0,0),2),((0,255,0),1)]
        vector<tuple<int, int, int>> vals;
        for (int y = 0; y < h; y++)
            for (int x = 0; x < w; x++)
                vals.push_back({img(x, y, 0, 0), img(x, y, 0, 1), img(x, y, 0, 2)});

        int count = 1;
        for (size_t i = 1; i <= vals.size(); i++) {
            if (i < vals.size() && vals[i] == vals[i - 1]) count++;
            else {
                auto [r, g, b] = vals[i - 1];
                fout << r << " " << g << " " << b << " " << count << " ";
                count = 1;
            }
        }
    }

    fout.close();
    cout << "已完成RLE压缩，结果保存至：" << compressedFile << endl;
}
```

此函数实现了将ppm格式的图像文件中的像素信息经过RLE算法压缩后写入txt文件中，即对图像的压缩操作，且对于纯色区域多的图像（例如color-block.ppm），压缩率接近28%

### 3.6 图像解压的函数

在本程序中，压缩后的图像将以txt文件的格式存储，因此解压函数需要读取此文件，并将其进行解析得到原始图像，再把解压后的像素信息写回ppm格式的图像文件中，其`decompressImage`函数如下：

```cpp
void decompressImage(const string &compressedFile, const string &output) {
    ifstream fin(compressedFile);
    int w, h, c;
    fin >> w >> h >> c;//读取图像的宽、高、通道数

    if (c == 1) {
        //灰度图像
        vector<int> vals;
        int v, count;
        while (fin >> v >> count)
            for (int i = 0; i < count; i++) vals.push_back(v);//根据RLE压缩格式还原像素值序列

        CImg<unsigned char> img(w, h, 1, 1, 0);
        int idx = 0;
        for (int y = 0; y < h; y++)
            for (int x = 0; x < w; x++)
                if (idx < (int)vals.size()) img(x, y) = vals[idx++];//将还原的像素值填充到图像对象中

        img.save_ascii(output.c_str());//先保存为CImg的ascii码格式，再修改其文件头部信息，变为标准的ppm格式

        // 去掉 CImg 自定义头并替换为 P2 头
        ifstream fin(output);
        string header_line;
        std::getline(fin, header_line); // 跳过第一行
        string data((istreambuf_iterator<char>(fin)), istreambuf_iterator<char>());
        fin.close();

        ofstream fout(output);
        fout << "P2\n" << img.width() << " " << img.height() << "\n255\n";
        fout << data;
        fout.close();

        //调用UI窗口展示解压后的图像
        img.display("Decompressed Gray");
        cout << "已解压灰度图：" << output << endl;
    } else {
        //彩色图像
        vector<tuple<int, int, int>> vals;
        int r, g, b, count;
        while (fin >> r >> g >> b >> count)
            for (int i = 0; i < count; i++) vals.push_back({r, g, b});//根据RLE压缩格式还原像素值序列

        CImg<unsigned char> img(w, h, 1, 3, 0);
        int idx = 0;
        //将还原的像素值填充到图像对象中
        for (int y = 0; y < h; y++)
            for (int x = 0; x < w; x++)
                if (idx < (int)vals.size()) {
                    auto [R, G, B] = vals[idx++];
                    img(x, y, 0, 0) = R;
                    img(x, y, 0, 1) = G;
                    img(x, y, 0, 2) = B;
                }

        ofstream fout(output);//手动写入标准的P3格式（ppm格式彩色图）
        fout << "P3\n" << img.width() << " " << img.height() << "\n255\n";
        for (int y = 0; y < img.height(); y++) {
            for (int x = 0; x < img.width(); x++) {
                int r = img(x, y, 0, 0);
                int g = img(x, y, 0, 1);
                int b = img(x, y, 0, 2);
                fout << r << " " << g << " " << b << " ";
            }
            fout << "\n";
        }
        fout.close();

        img.display("Decompressed Color");
        cout << "已解压彩色图：" << output << endl;
    }
    fin.close();
}
```

此函数首先读取函数首先读取压缩文件（txt）中的图像宽度、高度及通道数

- 若为灰度图（单通道），则按“像素值-重复次数”格式解码

- 若为彩色图（RGB三通道），则按“RGB重复次数”格式依次还原

还原出的像素序列被填充到CImg图像对象中，最后分别保存为符合标准的P2（灰度）或P3（彩色）格式的PPM文件，并在屏幕上显示解压结果

## 4.程序运行方式简要说明

### 4.1 编译命令

由于本程序使用到了CImg库及调用UI窗口的操作，因此编译命令为：

```bash
g++ main.cpp -o project2.exe -O2 -std=c++17 -I. -lgdi32 -lpthread -fexec-charset=UTF-8
```

其中：

- -O2 表示启用中级优化，提高程序运行效率
- -std=c++17 指定采用C++ 17标准
- -I. 用于指定头文件搜索路径为当前目录，确保CImg.h能正确引用
- -lgdi32、-lpthread 分别用于链接Windows图形库和多线程库，这些是CImg图像显示与处理所必需的
- -fexec-charset=UTF-8 用于设置得到的exe文件的编码格式为UTF-8，避免中文乱码

### 4.2 运行方式

1. 使用4.1中的编译命令得到project2.exe
2. 启动程序：在终端中输入./project2.exe或双击运行project2.exe
3. 程序显示功能菜单，用户基于菜单提示选择不同操作（图像读取、灰度化、缩放、压缩与解压）
4. 根据提示输入原图文件名与输出文件名，程序自动执行相应图像处理操作
5. 运行结束后，程序将在当前目录生成对应的输出图像文件，并在窗口中显示处理结果

该程序支持处理灰度图像与彩色图像，输出文件采用标准的 **PPM(P2/P3)** 格式，可被常见图像查看器正常打开。